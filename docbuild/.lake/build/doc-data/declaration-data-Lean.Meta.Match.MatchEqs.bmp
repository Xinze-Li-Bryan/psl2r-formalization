{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.genMatchCongrEqns\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">genMatchCongrEqns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span></div></div>","info":{"doc":"Generate the congruence equations for the given match auxiliary declaration.\nThe congruence equations have a completely unrestricted left-hand side (arbitrary discriminants),\nand take propositional equations relating the discriminants to the patterns as arguments. In this\nsense they combine a congruence lemma with the regular equation lemma.\nSince the motive depends on the discriminants, they are `HEq` equations.\n\nThe code duplicates a fair bit of the logic above, and has to repeat the calculation of the\n`notAlts`. One could avoid that and generate the generalized equations eagerly above, but they are\nnot always needed, so for now we live with the code duplication.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.genMatchCongrEqns","kind":"def","line":854,"name":"Lean.Meta.Match.genMatchCongrEqns","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L854-L929"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.registerMatchCongrEqns\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">registerMatchCongrEqns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqnNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.registerMatchCongrEqns","kind":"def","line":850,"name":"Lean.Meta.Match.registerMatchCongrEqns","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L850-L852"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.matchCongrEqnsExt\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">matchCongrEqnsExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Environment.html#Lean.EnvExtension\">EnvExtension</a> <span class=\"fn\">(<a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.matchCongrEqnsExt","kind":"opaque","line":844,"name":"Lean.Meta.Match.matchCongrEqnsExt","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L844-L848"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.getEquationsForImpl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">getEquationsForImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Match/MatchEqsExt.html#Lean.Meta.Match.MatchEqns\">MatchEqns</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.getEquationsForImpl","kind":"def","line":739,"name":"Lean.Meta.Match.getEquationsForImpl","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L739-L841"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult.subgoal\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">InjectionAnyResult</span>.<span class=\"name\">subgoal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult\">InjectionAnyResult</a></div></div>","info":{"doc":"`fvarId` refers to the local declaration selected for the application of the `injection` tactic. ","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult.subgoal","kind":"ctor","line":453,"name":"Lean.Meta.Match.InjectionAnyResult.subgoal","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L453-L454"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult.failed\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">InjectionAnyResult</span>.<span class=\"name\">failed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult\">InjectionAnyResult</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult.failed","kind":"ctor","line":452,"name":"Lean.Meta.Match.InjectionAnyResult.failed","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L452-L452"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult.solved\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">InjectionAnyResult</span>.<span class=\"name\">solved</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult\">InjectionAnyResult</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult.solved","kind":"ctor","line":451,"name":"Lean.Meta.Match.InjectionAnyResult.solved","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L451-L451"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">InjectionAnyResult</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.InjectionAnyResult","kind":"inductive","line":450,"name":"Lean.Meta.Match.InjectionAnyResult","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L450-L454"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.proveCondEqThm\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">proveCondEqThm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqPos </span><span class=\"fn\">heqNum</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Helper method for proving a conditional equational theorem associated with an alternative of\nthe `match`-eliminator `matchDeclName`. `type` contains the type of the theorem.\n\nThe `heqPos`/`heqNum` arguments indicate that these hypotheses are `Eq`/`HEq` hypotheses\nto substitute first; this is used for the generalized match equations.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.proveCondEqThm","kind":"def","line":384,"name":"Lean.Meta.Match.proveCondEqThm","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L384-L436"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.M\">M</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.go","kind":"opaque","line":333,"name":"Lean.Meta.Match.SimpH.go","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L333-L339"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.trySubstVarsAndContradiction\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">trySubstVarsAndContradiction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">forbidden</span> : <a href=\"./Lean/Expr.html#Lean.FVarIdSet\">FVarIdSet</a> := <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Auxiliary tactic that tries to replace as many variables as possible and then apply `contradiction`.\nWe use it to discard redundant hypotheses.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.trySubstVarsAndContradiction","kind":"opaque","line":272,"name":"Lean.Meta.Match.SimpH.trySubstVarsAndContradiction","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L272-L285"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.M\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.M","kind":"def","line":240,"name":"Lean.Meta.Match.SimpH.M","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L240-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.eqsNew\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">State</span>.<span class=\"name\">eqsNew</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.eqsNew","kind":"def","line":238,"name":"Lean.Meta.Match.SimpH.State.eqsNew","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L238-L238"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.eqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">State</span>.<span class=\"name\">eqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.eqs","kind":"def","line":237,"name":"Lean.Meta.Match.SimpH.State.eqs","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L237-L237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.xs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">State</span>.<span class=\"name\">xs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.xs","kind":"def","line":236,"name":"Lean.Meta.Match.SimpH.State.xs","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L236-L236"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.mvarId\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">State</span>.<span class=\"name\">mvarId</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.mvarId","kind":"def","line":235,"name":"Lean.Meta.Match.SimpH.State.mvarId","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">State</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs </span><span class=\"fn\">eqs </span><span class=\"fn\">eqsNew</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State\">State</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State.mk","kind":"ctor","line":234,"name":"Lean.Meta.Match.SimpH.State.mk","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L234-L234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">SimpH</span>.<span class=\"name\">State</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"State for the equational theorem hypothesis simplifier.\n\nRecall that each equation contains additional hypotheses to ensure the associated case does not taken by previous cases.\nWe have one hypothesis for each previous case.\n\nEach hypothesis is of the form `forall xs, eqs → False`\n\nWe use tactics to minimize code duplication.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.SimpH.State","kind":"structure","line":224,"name":"Lean.Meta.Match.SimpH.State","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L224-L238"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.mkAppDiscrEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">mkAppDiscrEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">alt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numDiscrEqs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Given an application of an matcher arm `alt` that is expecting the `numDiscrEqs`, and\nan array of `discr = pattern` equalities (one for each discriminant), apply those that\nare expected by the alternative.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.mkAppDiscrEqs","kind":"def","line":203,"name":"Lean.Meta.Match.mkAppDiscrEqs","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L203-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.forallAltTelescope\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">forallAltTelescope</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">altType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">altNumParams </span><span class=\"fn\">numDiscrEqs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Extension of `forallAltTelescope` that continues further:\n\nEquality parameters associated with the `h : discr` notation are replaced with `rfl` proofs.\nRecall that this kind of parameter always occurs after the parameters corresponding to pattern\nvariables.\n\nThe continuation `k` takes four arguments `ys args mask type`.\n- `ys` are variables for the hypotheses that have not been eliminated.\n- `eqs` are variables for equality hypotheses associated with discriminants annotated with `h : discr`.\n- `args` are the arguments for the alternative `alt` that has type `altType`. `ys.size <= args.size`\n- `mask[i]` is true if the hypotheses has not been eliminated. `mask.size == args.size`.\n- `type` is the resulting type for `altType`.\n\nWe use the `mask` to build the splitter proof. See `mkSplitterProof`.\n\nThis can be used to use the alternative of a match expression in its splitter.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.forallAltTelescope","kind":"def","line":161,"name":"Lean.Meta.Match.forallAltTelescope","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L161-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.forallAltVarsTelescope\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">forallAltVarsTelescope</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">altType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">altNumParams </span><span class=\"fn\">numDiscrEqs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Similar to `forallTelescopeReducing`, but\n\n1. Eliminates arguments for named parameters and the associated equation proofs.\n\n2. Instantiate the `Unit` parameter of an otherwise argumentless alternative.\n\nIt does not handle the equality parameters associated with the `h : discr` notation.\n\nThe continuation `k` takes four arguments `ys args mask type`.\n- `ys` are variables for the hypotheses that have not been eliminated.\n- `args` are the arguments for the alternative `alt` that has type `altType`. `ys.size <= args.size`\n- `mask[i]` is true if the hypotheses has not been eliminated. `mask.size == args.size`.\n- `type` is the resulting type for `altType`.\n\nWe use the `mask` to build the splitter proof. See `mkSplitterProof`.\n\nThis can be used to use the alternative of a match expression in its splitter.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.forallAltVarsTelescope","kind":"def","line":100,"name":"Lean.Meta.Match.forallAltVarsTelescope","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L100-L158"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.unfoldNamedPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">unfoldNamedPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.unfoldNamedPattern","kind":"def","line":92,"name":"Lean.Meta.Match.unfoldNamedPattern","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L92-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.casesOnStuckLHS?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">casesOnStuckLHS?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.casesOnStuckLHS?","kind":"def","line":87,"name":"Lean.Meta.casesOnStuckLHS?","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L87-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.casesOnStuckLHS\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">casesOnStuckLHS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Helper method for `proveCondEqThm`. Given a goal of the form `C.rec ... xMajor = rhs`,\napply `cases xMajor`. ","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.casesOnStuckLHS","kind":"def","line":52,"name":"Lean.Meta.casesOnStuckLHS","sourceLink":"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Lean/Meta/Match/MatchEqs.lean#L52-L85"}}],"imports":["Lean.Meta.CtorRecognizer","Lean.Meta.Match.Match","Lean.Meta.Match.MatchEqsExt","Lean.Meta.Tactic.Apply","Lean.Meta.Tactic.Refl","Lean.Meta.Tactic.Delta","Lean.Meta.Tactic.Injection","Lean.Meta.Tactic.Contradiction","Lean.Meta.Tactic.SplitIf"],"instances":[],"name":"Lean.Meta.Match.MatchEqs"}